<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Rayson Wen">





<title>乱七八糟 | Rayson13&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Rayson13&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Rayson13&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">乱七八糟</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Rayson Wen</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 31, 2022&nbsp;&nbsp;19:18:07</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="1-手写单例模式"><a href="#1-手写单例模式" class="headerlink" title="1.手写单例模式"></a>1.手写单例模式</h4><p>单例模式的要点：</p>
<ul>
<li>某个类只能有一个实例<ul>
<li>构造器私有化</li>
</ul>
</li>
<li>类必须自行创建整个实例<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
</li>
<li>类必须自行向整个系统提供这个实例<ul>
<li>对外提供获取该实例对象的方式</li>
</ul>
</li>
</ul>
<p><strong>单例模式可以分为饿汉式和懒汉式两大类</strong></p>
<p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ol>
<li>直接实例化饿汉式（简洁直观）</li>
<li>静态代码块饿汉式（适合复杂实例化）</li>
<li>枚举式（最简洁）</li>
</ol>
<p>懒汉式：</p>
<ol start="4">
<li>线程不安全式（适用于单线程）</li>
<li>双重校验式，线程安全（适用于多线程）</li>
<li>静态内部类式（适用于多线程）</li>
</ol>
<p><strong>1.饿汉式-静态常量方式（线程安全）</strong></p>
<p><strong>说明：</strong> 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。</p>
<p><strong>优点：</strong> 提前实例化好了一个实例，避免了线程不安全问题的出现。</p>
<p><strong>缺点：</strong> 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。</p>
<p>类加载时就初始化实例，避免了多线程同步问题。天然线程安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static Singleton instance = new Singleton();</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式-静态代码块方式</strong></p>
<p>其实就是在上面 静态常量饿汉式 实现上稍微变动了一下，将类的实例化放在了静态代码块中而已。其他没区别.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public clas Singleton&#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	static&#123;</span><br><span class="line">		instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">	public static Singelton getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.懒汉式（线程不安全）</strong></p>
<p>这是最基本的实现方式，第一次调用才初始化，实现了懒加载的特性。多线程场景下禁止使用，因为可能会产生多个对象，不再是单例。</p>
<p><strong>说明：</strong> 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。</p>
<p><strong>优点：</strong> 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。</p>
<p><strong>缺点：</strong> 线程不安全，多线程环境下，如果多个线程同时进入了 if (instance &#x3D;&#x3D; null) ，若此时还未实例化，也就是instance &#x3D;&#x3D; null，那么就会有多个线程执行 instance &#x3D; new Singleton(); ，就会实例化多个实例；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(instance==null)&#123;</span><br><span class="line">			instance = new Singleton;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.懒汉式（线程安全，方法上加同步锁）</strong></p>
<p><strong>说明：</strong> 实现和 线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上 加了一把 锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。</p>
<p><strong>优点：</strong> 延迟实例化，节约了资源，并且是线程安全的。</p>
<p><strong>缺点：</strong> 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方***使线程阻塞，等待时间过长。</p>
<p>和上面 懒汉式（线程不安全）实现上唯一不同是：获取实例的getInstance()方法上加了同步锁。保证了多线程场景下的单例。但是效率会有所折损，不过还好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	private Singleton&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static synchronized Singleton getInstance()&#123;</span><br><span class="line">		if(instance==null)&#123;</span><br><span class="line">			instance = new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.双重校验锁（线程安全，效率高）</strong></p>
<p>此种实现中不用每次需要获得锁，减少了获取锁和等待的事件。<br>注意volatile关键字的使用，保证了各线程对singleton静态实例域修改的可见性。</p>
<p><strong>说明:</strong> 双重检查数相当于是改进了 线程安全的懒汉式。线程安全的懒汉式 的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。</p>
<p><strong>为什么使用 volatile 关键字修饰了 uniqueInstance 实例变量 ？</strong> </p>
<p> instance &#x3D; new Singleton(); 这段代码执行时分为三步：</p>
<ol>
<li>为 instance 分配内存空间 </li>
<li>初始化 instance </li>
<li>将 instance 指向分配的内存地址</li>
</ol>
<p>正常的执行顺序当然是 1&gt;2&gt;3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。<br>单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。<br>例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getInstance()，发现 instance 不为空，便获取 instance 实例，但是其实此时的 instance 还没有初始化。</p>
<p>解决办法就是加一个 volatile 关键字修饰instance ，volatile 会禁止 JVM 的指令重排，就可以保证多线程环境下的安全运行。</p>
<p><strong>优点：</strong> 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。</p>
<p><strong>缺点：</strong> volatile 关键字，对性能也有一些影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	privaete volatile static Singleton instance;</span><br><span class="line">	privaete Singleton()&#123;&#125;;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(instance==null)&#123;</span><br><span class="line">			synchronized(Singleton.class)&#123;</span><br><span class="line">				if(instance==null)&#123;</span><br><span class="line">					instance = new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.静态内部类实现单例（线程安全，效率高）</strong></p>
<p><strong>说明：</strong> 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。</p>
<p><strong>优点：</strong> 延迟实例化，节约了资源；且线程安全；性能也提高了。</p>
<p>这种方式下 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。<br>注意内部类SingletonHolder要用static修饰且其中的静态变量INSTANCE必须是final的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static class SingletonHolder&#123;</span><br><span class="line">		private static final Singleton instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	private Singleton()&#123;&#125;;</span><br><span class="line">	public static final Singleton getInstance()&#123;</span><br><span class="line">		return SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.枚举类实现（线程安全）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	//添加自己需要的操作</span><br><span class="line">	public void doSomeThiing()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong> 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。</p>
<p><strong>优点：</strong> 写法简单，线程安全，天然防止反射和反序列化调用。</p>
<ul>
<li><strong>防止反序列化</strong><br><strong>序列化：</strong>把java对象转换为字节序列的过程；<br><strong>反序列化：</strong> 通过这些字节序列在内存中新建java对象的过程；<br><strong>说明：</strong> 反序列化 将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例。<br><strong>枚举类天然防止反序列化。</strong><br>其他单例模式 可以通过 重写 readResolve() 方法，从而防止反序列化，使实例唯一重写 readResolve() :</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">	return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h5><p><strong>应用场景举例：</strong> </p>
<ul>
<li>网站计数器。 </li>
<li>应用程序的日志应用。 </li>
<li>Web项目中的配置对象的读取。 </li>
<li>数据库连接池。 </li>
<li>多线程池。 </li>
<li>……</li>
</ul>
<p><strong>使用场景总结：</strong></p>
<ul>
<li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能。 </li>
<li><strong>经常使用的对象，但实例化时耗费时间或者资源多</strong>，如数据库连接池，使用单例模式，可以提高性能，降低资源损坏。 </li>
<li><strong>使用线程池之类的控制资源时</strong>，使用单例模式，可以方便资源之间的通信。</li>
</ul>
<h4 id="2-Kafka-RabbitMQ"><a href="#2-Kafka-RabbitMQ" class="headerlink" title="2.Kafka,RabbitMQ"></a>2.Kafka,RabbitMQ</h4><h4 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3.设计模式"></a>3.设计模式</h4><p>单例模式：某个类只能有一个实例，提供一个全局的访问点</p>
<p>简单工厂：一个工厂根据传入的参量决定创建出哪一种产品类的实例</p>
<p>工厂方法：定义一个创建对象的接口，让子类决定实例化哪个类</p>
<p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类</p>
<h4 id="4-kafka如何保证消息不丢失"><a href="#4-kafka如何保证消息不丢失" class="headerlink" title="4.kafka如何保证消息不丢失"></a>4.kafka如何保证消息不丢失</h4><ul>
<li><p><strong>生产者丢失消息的情况</strong></p>
<ol>
<li><p>生产者(Producer) 调用send方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用send方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 send 方法发送消息实际上是异步的操作，我们可以通过 get()方法获取调用结果，但是这样也让它变为了同步操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line">if (sendResult.getRecordMetadata() != null) &#123;</span><br><span class="line">  logger.info(&quot;生产者成功发送消息到&quot; + sendResult.getProducerRecord().topic() + &quot;-&gt; &quot; + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加回调函数的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">        future.addCallback(result -&gt; logger.info(&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(&quot;生产者发送消失败，原因：&#123;&#125;&quot;, ex.getMessage()));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>消费者丢失消息的情况</strong></p>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
</li>
<li><p><strong>kafka弄丢了消息</strong></p>
<p> Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>
<p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p><strong>replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
</li>
</ul>
<h4 id="5-Kafka如何保证消息不重复消费"><a href="#5-Kafka如何保证消息不重复消费" class="headerlink" title="5.Kafka如何保证消息不重复消费"></a>5.Kafka如何保证消息不重复消费</h4><p><strong>kafka出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>
<li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交offset合适？</strong><ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h4 id="6-排序算法"><a href="#6-排序算法" class="headerlink" title="6.排序算法"></a>6.排序算法</h4><ol>
<li><p>冒泡排序(BubbleSort)</p>
<ul>
<li><p><strong>基本思想：</strong>两个数比较大小，较大的数下沉，较小的数冒起来</p>
</li>
<li><p><strong>过程：</strong></p>
<ul>
<li><p>比较相邻的两个数据，如果第二个数小，就交换位置。</p>
</li>
<li><p>从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。</p>
</li>
<li><p>继续重复上述过程，依次将第2.3…n-1个最小数排好位置。</p>
<img src="/2022/05/31/zonghe/1.png" class title="This is an example image"></li>
</ul>
</li>
<li><p><strong>平均时间复杂度：</strong>O(n2)</p>
</li>
<li><p>优化：</p>
<ul>
<li><strong>针对问题：</strong><br>数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。</li>
<li><strong>方案：</strong><br>设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。<br>这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort1(int [] arr)&#123;</span><br><span class="line"></span><br><span class="line">   int temp;//临时变量</span><br><span class="line">   boolean flag;//是否交换的标志</span><br><span class="line">   for(int i=0; i&lt;arr.length-1; i++)&#123;   //表示趟数，一共 arr.length-1 次</span><br><span class="line"></span><br><span class="line">       // 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换</span><br><span class="line">       flag = false;</span><br><span class="line">       </span><br><span class="line">       for(int j=arr.length-1; j&gt;i; j--)&#123; //选出该趟排序的最大值往后移动</span><br><span class="line"></span><br><span class="line">           if(arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">               temp = arr[j];</span><br><span class="line">               arr[j] = arr[j-1];</span><br><span class="line">               arr[j-1] = temp;</span><br><span class="line">               flag = true;    //只要有发生了交换，flag就置为true</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</span><br><span class="line">       if(!flag) break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>选择排序(SelctionSort)</p>
<ul>
<li><p><strong>基本思想：</strong><br>在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；<br>第二次遍历n-2个数，找到最小的数值与第二个元素交换；<br>。。。<br>第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。</p>
</li>
<li><p>过程：</p>
<img src="/2022/05/31/zonghe/2.png" class title="This is an example image">
</li>
<li><p><strong>平均时间复杂度：</strong>O(n2)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void select_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   for(int i=0;i&lt;lenth-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">       int minIndex = i;</span><br><span class="line">       for(int j=i+1;j&lt;lenth;j++)&#123;</span><br><span class="line">          if(array[j]&lt;array[minIndex])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(minIndex != i)&#123;</span><br><span class="line">           int temp = array[i];</span><br><span class="line">           array[i] = array[minIndex];</span><br><span class="line">           array[minIndex] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入排序(Insertion Sort)</p>
<ul>
<li><p><strong>基本思想：</strong><br>在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
</li>
<li><p>过程：</p>
<img src="/2022/05/31/zonghe/3.png" class title="This is an example image">
</li>
<li><p><strong>平均时间复杂度：</strong>O(n2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void  insert_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   int temp;</span><br><span class="line"></span><br><span class="line">   for(int i=0;i&lt;lenth-1;i++)&#123;</span><br><span class="line">       for(int j=i+1;j&gt;0;j--)&#123;</span><br><span class="line">           if(array[j] &lt; array[j-1])&#123;</span><br><span class="line">               temp = array[j-1];</span><br><span class="line">               array[j-1] = array[j];</span><br><span class="line">               array[j] = temp;</span><br><span class="line">           &#125;else&#123;         //不需要交换</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>希尔排序(Shell Sort)</p>
<ul>
<li><p><strong>前言：</strong><br>数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;<br>数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;<br>如果数据序列基本有序，使用插入排序会更加高效。</p>
</li>
<li><p><strong>基本思想：</strong><br>在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。<br>然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。</p>
</li>
<li><p>过程:</p>
<img src="/2022/05/31/zonghe/4.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void shell_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   int temp = 0;</span><br><span class="line">   int incre = lenth;</span><br><span class="line"></span><br><span class="line">   while(true)&#123;</span><br><span class="line">       incre = incre/2;</span><br><span class="line"></span><br><span class="line">       for(int k = 0;k&lt;incre;k++)&#123;    //根据增量分为若干子序列</span><br><span class="line"></span><br><span class="line">           for(int i=k+incre;i&lt;lenth;i+=incre)&#123;</span><br><span class="line"></span><br><span class="line">               for(int j=i;j&gt;k;j-=incre)&#123;</span><br><span class="line">                   if(array[j]&lt;array[j-incre])&#123;</span><br><span class="line">                       temp = array[j-incre];</span><br><span class="line">                       array[j-incre] = array[j];</span><br><span class="line">                       array[j] = temp;</span><br><span class="line">                   &#125;else&#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(incre == 1)&#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>快速排序(Quicksort)</p>
<ul>
<li><p><strong>基本思想：（分治）</strong></p>
<ul>
<li>先从数列中取出一个数作为key值；</li>
<li>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</li>
<li>对左右两个小数列重复第二步，直至各区间只有1个数。</li>
</ul>
</li>
<li><p><strong>平均时间复杂度：</strong>O(N*logN)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int a[],int l,int r)&#123;</span><br><span class="line">     if(l&gt;=r)</span><br><span class="line">       return;</span><br><span class="line"></span><br><span class="line">     int i = l; int j = r; int key = a[l];//选择第一个数为key</span><br><span class="line"></span><br><span class="line">     while(i&lt;j)&#123;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[j]&gt;=key)//从右向左找第一个小于key的值</span><br><span class="line">             j--;</span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[i] = a[j];</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[i]&lt;key)//从左向右找第一个大于key的值</span><br><span class="line">             i++;</span><br><span class="line"></span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[j] = a[i];</span><br><span class="line">             j--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //i == j</span><br><span class="line">     a[i] = key;</span><br><span class="line">     quickSort(a, l, i-1);//递归调用</span><br><span class="line">     quickSort(a, i+1, r);//递归调用</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>归并排序(Merge Sort)</p>
<ul>
<li><p><strong>基本思想</strong>：</p>
<p>其的基本思路就是将数组分成2组A，B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。如何让这2组组内数据有序了？<br>可以将A，B组各自再分成2组。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过<strong>先递归的分解数列</strong>，<strong>再合并数列</strong>就完成了归并排序。</p>
</li>
<li><p>过程：</p>
<img src="/2022/05/31/zonghe/5.png" class title="This is an example image">
</li>
<li><p><strong>平均时间复杂度：</strong>O(NlogN)<br>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void merge_sort(int a[],int first,int last,int temp[])&#123;</span><br><span class="line"></span><br><span class="line">  if(first &lt; last)&#123;</span><br><span class="line">      int middle = (first + last)/2;</span><br><span class="line">      merge_sort(a,first,middle,temp);//左半部分排好序</span><br><span class="line">      merge_sort(a,middle+1,last,temp);//右半部分排好序</span><br><span class="line">      mergeArray(a,first,middle,last,temp); //合并左右部分</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//合并 ：将两个序列a[first-middle],a[middle+1-end]合并</span><br><span class="line">public static void mergeArray(int a[],int first,int middle,int end,int temp[])&#123;    </span><br><span class="line">  int i = first;</span><br><span class="line">  int m = middle;</span><br><span class="line">  int j = middle+1;</span><br><span class="line">  int n = end;</span><br><span class="line">  int k = 0;</span><br><span class="line">  while(i&lt;=m &amp;&amp; j&lt;=n)&#123;</span><br><span class="line">      if(a[i] &lt;= a[j])&#123;</span><br><span class="line">          temp[k] = a[i];</span><br><span class="line">          k++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          temp[k] = a[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(i&lt;=m)&#123;</span><br><span class="line">      temp[k] = a[i];</span><br><span class="line">      k++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(j&lt;=n)&#123;</span><br><span class="line">      temp[k] = a[j];</span><br><span class="line">      k++;</span><br><span class="line">      j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(int ii=0;ii&lt;k;ii++)&#123;</span><br><span class="line">      a[first + ii] = temp[ii];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>堆排序(HeapSort)</p>
</li>
<li><p>基数排序(RadixSort)</p>
</li>
</ol>
<p>​    <img src="/2022/05/31/zonghe/6.png" class title="This is an example image"></p>
<h4 id="7-Unicode-和-UTF-8"><a href="#7-Unicode-和-UTF-8" class="headerlink" title="7.Unicode 和 UTF-8"></a>7.Unicode 和 UTF-8</h4><p>Unicode是“字符集”，UTF-8 是“编码规则”。</p>
<ul>
<li>Unicode （”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“）为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。Unicode 就相当于一张表，建立了字符与编号之间的联系。</li>
<li>为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位，UTF-32就是每次32个位。UTF-8就是在互联网上使用最广的一种Unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是Unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。</li>
</ul>
<h4 id="8-Redis为什么不用b-树，MySQL为什么不用跳表？"><a href="#8-Redis为什么不用b-树，MySQL为什么不用跳表？" class="headerlink" title="8.Redis为什么不用b+树，MySQL为什么不用跳表？"></a>8.Redis为什么不用b+树，MySQL为什么不用跳表？</h4><ul>
<li>Redis是直接操作内存的并不需要磁盘io而MySQL需要去读取io，所以mysql要使用b+树的方式减少磁盘io，B+树的原理是 叶子节点存储数据，非叶子节点存储索引，每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一<br>  而Redis是 内存中读取数据，不涉及IO，因此使用了跳表，跳表明显是更快更简单的方式。</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Rayson Wen</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://rayson13.github.io/2022/05/31/zonghe/">https://rayson13.github.io/2022/05/31/zonghe/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/07/08/intrest/">智力题？</a>
            
            
            <a class="next" rel="next" href="/2022/05/16/spring/">spring相关</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Rayson Wen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>