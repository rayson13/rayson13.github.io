<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Rayson Wen">





<title>计算机网络知识点 | Rayson13&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Rayson13&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Rayson13&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机网络知识点</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Rayson Wen</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 8, 2022&nbsp;&nbsp;19:59:23</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="1-TCP-x2F-UDP"><a href="#1-TCP-x2F-UDP" class="headerlink" title="1.TCP&#x2F;UDP"></a>1.TCP&#x2F;UDP</h4><ul>
<li>TCP&#x2F;IP即传输控制&#x2F;网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成 对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢 失，没有重复，并且按顺序到达</li>
<li>UDP它是属于TCP&#x2F;IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可 靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的 地，到达目的地的时间以及内容的正确性都是不能被保证的。</li>
<li>TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连 接传输的数据不会丢失，没有重复，并且按顺序到达；</li>
<li>UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li>TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据 包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li>TCP首部开销（20字节）比UDP首部开销（8字节）要大,UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
<h4 id="2-ARP协议（Address-Resolution-Protocol）"><a href="#2-ARP协议（Address-Resolution-Protocol）" class="headerlink" title="2.ARP协议（Address Resolution Protocol）"></a>2.ARP协议（Address Resolution Protocol）</h4><ul>
<li>ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的 局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机 时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这 个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在发送自己的 ARP 请求 时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主 机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一 个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再 进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</li>
<li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的 某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做。</li>
</ul>
<h4 id="3-输入网址到获得页面的过程"><a href="#3-输入网址到获得页面的过程" class="headerlink" title="3.输入网址到获得页面的过程"></a>3.输入网址到获得页面的过程</h4><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进 行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应 的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并 向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h4 id="4-TCP三次握手"><a href="#4-TCP三次握手" class="headerlink" title="4.TCP三次握手"></a>4.TCP三次握手</h4><ol>
<li>什么是TCP的三次握手</li>
</ol>
<ul>
<li>在网络数据传输中，传输层协议TCP是要建立连接的可靠传输，TCP建立连接的过程，我们称为三 次握手。</li>
</ul>
<ol start="2">
<li><p>三次握手的具体细节</p>
<img src="/2022/04/08/computer-network/1.png" class title="This is an example image"></li>
</ol>
<ul>
<li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状 态；</li>
<li>第二次握手：Server收到Client的SYN&#x3D;1之后，知道客户端请求建立连接，将自己的SYN置1，ACK 置1，产生一个acknowledge number&#x3D;sequence number+1，并随机产生一个自己的初始序列 号，发送给客户端；进入SYN_RCVD状态；</li>
<li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将 自己的ACK置为1，产生一个acknowledge number&#x3D;服务器发的序列号+1，发送给服务器；进入 ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入 ESTABLISHED状态；完成三次握手，连接建立。</li>
</ul>
<ol start="3">
<li><p>用现实理解三次握手的具体细节</p>
<ul>
<li>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收机能正 常。</li>
</ul>
<ol>
<li>第一次握手：客户什么都不能确认；服务器确认了对方发送正常</li>
<li>第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常</li>
<li>第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常。所以三次握手就能确认双发收发功能都正常，缺一不可。</li>
</ol>
</li>
<li><p>建立连接可以两次握手吗？为什么?</p>
<ul>
<li>不可以。</li>
<li>因为可能会出现已失效的连接请求报文段又传到了服务器端。client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为 是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设 不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出 建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新 的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。 采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认 发出确认。server由于收不到确认，就知道 client 并没有要求建立连接。</li>
<li>而且，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到）， 也无法保证Client和Server之间成功互换初始序列号。</li>
</ul>
</li>
<li><p>可以采用四次握手吗？为什么？</p>
<ul>
<li>可以。三次握手都可以保证连接成功了，何况是四次，但是会降低传输的效率。</li>
</ul>
</li>
<li><p>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</p>
<ul>
<li>Server端：由于Server没有收到ACK确认，因此会每隔 3秒 重发之前的SYN+ACK（默认重发五 次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</li>
<li>Client端，会出现两种情况：<ol>
<li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的， 所以服务器收到数据之后会读取 ACK number，进入 establish 状态</li>
<li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</li>
</ol>
</li>
</ul>
</li>
<li><p>如果已经建立了连接，但客户端出现了故障怎么办？</p>
<ul>
<li>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时 还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若 一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li>
</ul>
</li>
<li><p>初始序列号是什么？</p>
<ul>
<li>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列 号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以 确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如 果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经 被B成功接受。</li>
</ul>
</li>
</ol>
<h4 id="5-TCP四次握手"><a href="#5-TCP四次握手" class="headerlink" title="5.TCP四次握手"></a>5.TCP四次握手</h4><ol>
<li><p>什么是TCP的四次挥手</p>
<ul>
<li>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</li>
</ul>
</li>
<li><p>四次挥手的具体细节</p>
   <img src="/2022/04/08/computer-network/2.png" class title="This is an example image">

<ol>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK&#x3D;1，acknowledge number&#x3D;收到的序列号+1； 进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个 acknowledge number&#x3D;序列号+1给服务器；服务器收到后，确认acknowledge number后，变为 CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入 CLOSED状态。完成四次挥手。</li>
</ol>
</li>
<li><p>用现实理解三次握手的具体细节TCP的四次挥手</p>
<ul>
<li>四次挥手断开连接是因为要确定数据全部传书完了<ol>
<li>客户与服务器交谈结束之后，客户要结束此次会话，就会对服务器说：我要关闭连接了（第一 次挥手）</li>
<li>服务器收到客户的消息后说：好的，你要关闭连接了。（第二次挥手）</li>
<li>然后服务器确定了没有话要和客户说了，服务器就会对客户说，我要关闭连接了。(第三次挥手)</li>
<li>客户收到服务器要结束连接的消息后说：已收到你要关闭连接的消息。(第四次挥手)，才关闭</li>
</ol>
</li>
</ul>
</li>
<li><p>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什 么）？</p>
<ul>
<li>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</li>
</ul>
</li>
<li><p>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</p>
<ul>
<li>客户端没有收到ACK确认，会重新发送FIN请求。</li>
</ul>
</li>
<li><p>客户端TIME_WAIT状态的意义是什么？</p>
<ul>
<li>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的 ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就 会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的 最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则 结束TCP连接。</li>
</ul>
</li>
</ol>
<h4 id="6-TCP流量控制"><a href="#6-TCP流量控制" class="headerlink" title="6.TCP流量控制"></a>6.TCP流量控制</h4><ul>
<li><p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>
</li>
<li><p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>
</li>
<li><p>零窗口(接受窗口为0)？</p>
<p>接收方没有能力接受数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p>
</li>
</ul>
<h4 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7.TCP拥塞控制"></a>7.TCP拥塞控制</h4><ul>
<li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li>
<li>当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.<ul>
<li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></li>
</ul>
</li>
<li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</li>
</ul>
<h4 id="8-HTTP和HTTPS"><a href="#8-HTTP和HTTPS" class="headerlink" title="8.HTTP和HTTPS"></a>8.HTTP和HTTPS</h4><ol>
<li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li>
<li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li>
<li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li>
<li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li>
</ol>
<h4 id="9-HTTP请求常见状态码"><a href="#9-HTTP请求常见状态码" class="headerlink" title="9.HTTP请求常见状态码"></a>9.HTTP请求常见状态码</h4><ol>
<li>2xx状态码：操作成功。200 OK</li>
<li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li>
<li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li>
<li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li>
</ol>
<h4 id="9-RIP-Routing-Information-Protocol-距离矢量路由协议"><a href="#9-RIP-Routing-Information-Protocol-距离矢量路由协议" class="headerlink" title="9.RIP (Routing Information Protocol, 距离矢量路由协议)"></a>9.RIP (Routing Information Protocol, 距离矢量路由协议)</h4><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p>
<h4 id="10-计算机网络体系结构"><a href="#10-计算机网络体系结构" class="headerlink" title="10.计算机网络体系结构"></a>10.计算机网络体系结构</h4><img src="/2022/04/08/computer-network/3.jpg" class title="This is an example image">

<p>各层协议：<strong>应用层：</strong>HTTP(超文本传输协议) ，DNS(域名系统) ，FTP(文件传输协议) ，SMTP(简单邮件传送协议)</p>
<p>​                   <strong>运输层：</strong> TCP,UDP</p>
<p>​                   <strong>网络层：</strong>IP,ARP</p>
<h4 id="11-TCP如何保证可靠传输？"><a href="#11-TCP如何保证可靠传输？" class="headerlink" title="11.TCP如何保证可靠传输？"></a>11.TCP如何保证可靠传输？</h4><p>TCP通过三次握手建立可靠连接</p>
<p>①数据被分割成 TCP 认为最适合发送的数据包。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，将有序数据传送给应用层。<strong>TCP通过序列号和确认应答提高可靠性</strong></p>
<p>②校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的校验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p>③流量控制： TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。</p>
<p>④拥塞控制： 当网络拥塞时，减少数据的发送。</p>
<p>⑤ARQ协议：分为停止等待ARQ协议和连续ARQ协议</p>
<h4 id="12-ARQ-自动重传请求（Automatic-Repeat-reQuest，ARQ）"><a href="#12-ARQ-自动重传请求（Automatic-Repeat-reQuest，ARQ）" class="headerlink" title="12.ARQ 自动重传请求（Automatic Repeat-reQuest，ARQ）"></a>12.ARQ 自动重传请求（Automatic Repeat-reQuest，ARQ）</h4><ul>
<li>停止等待ARQ：它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</li>
<li>连续ARQ协议：(流水线的传输方式)可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
</ul>
<h4 id="13-TCP粘包"><a href="#13-TCP粘包" class="headerlink" title="13.TCP粘包"></a>13.TCP粘包</h4><p><strong>原因：</strong></p>
<ol>
<li>UDP协议的保护消息边界使得每一个消息都是独立的</li>
<li>而tcp是基于流的传输，流传输却把数据当作一串数据流，他不认为数据是一个一个的消息</li>
<li>发送端需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方不及时接收缓冲区的包，造成多个包粘包</li>
</ol>
<p>（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p>
<p>（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p>
<p><strong>解决办法：</strong></p>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP程序收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</p>
<h4 id="14-HTTP-1-0、1-1、-2-0、-3-0"><a href="#14-HTTP-1-0、1-1、-2-0、-3-0" class="headerlink" title="14.HTTP 1.0、1.1、 2.0、 3.0"></a>14.HTTP 1.0、1.1、 2.0、 3.0</h4><ul>
<li><p>HTTP 1.0</p>
<ul>
<li>特点：<ul>
<li>无状态：服务器既不跟踪每个客户单，也不记录过去的请求（无状态）。</li>
<li>无连接：浏览器每次请求都需要与服务器建立一个TCP连接，即三次握手，服务器处理完成以后立即断开TCP连接。</li>
<li>无 host：即没有 http request header host，也就是http请求头里的host。</li>
</ul>
</li>
<li>问题：<ul>
<li>无法复用连接: 每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</li>
<li>队头阻塞（head of line blocking）: 由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</li>
<li>无法断点续传：由于请求是无状态的，所以无法断点续传，也无法传输对象的一部分，必须一次性传输整个对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP 1.1</p>
<ul>
<li>特点：<ul>
<li>长连接：增加Connection字段，通过设置<strong>Keep-Alive</strong>保持HTTP连接不断卡。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</li>
<li>管道化（pipelining）— 尴尬的假并行传输，即能够“并行”发送多个请求。（注意，这里的“并行”并不是真正意义上的并行传输），服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</li>
<li>缓存处理 — 强缓存、协商缓存，启发式缓存（新增），加入了缓存处理（强缓存和协商缓存），新的字段如cache-control。</li>
<li>支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）。</li>
</ul>
</li>
<li>问题：<ul>
<li>由于无法解决队头阻塞（head of line blocking）的问题，长连接会给服务器造成压力，而且同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么直接默认关闭，并且开启的条件很苛刻。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP 2.0</p>
<ul>
<li><p>特点：</p>
<ul>
<li><p>二进制分帧：在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1的性能限制，改进传输性能。</p>
</li>
<li><p>多路复用（或连接共享）-真并行传输：所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（Stream_id）重新封装。多路复用可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。</p>
<blockquote>
<ul>
<li><strong>流（stream）</strong>：已建立连接上的双向字节流。</li>
<li><strong>消息</strong>：与逻辑消息对应的完整的一系列数据帧。</li>
<li><strong>帧（frame）</strong>：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）</li>
</ul>
</blockquote>
</li>
<li><p>头部压缩，使用 encoder 来减少需要传输的 header 大小，通讯双方各自维护一个header_files 的索引表，既避免重复header的传输，又减少了需要传输的大小。不需要发送值，直接发送 key 缩减头部大小，减少发送包的数量从而降低延迟。</p>
</li>
<li><p>服务器推送（Sever push）：服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP 3.0</p>
<ul>
<li><p>特点：基于google的QUIC协议，而quic协议是使用udp实现的</p>
<ul>
<li><p>0-RTT 建连</p>
<blockquote>
<ul>
<li>传输层0-RTT就能建立连接</li>
<li>加密层0-RTT就能建立加密连接</li>
</ul>
</blockquote>
</li>
<li><p>多路复用：QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p>
</li>
<li><p>更好的移动端表现：UIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p>
</li>
<li><p>加密认证：</p>
</li>
<li><p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。QUIC的packet可以说武装到了牙齿，除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p>
</li>
<li><p>向前纠错机制：QUIC协议有一个非常独特的特性，称为向前纠错（Foward Error Connec，FEC），每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="15-如何保证HTTP传输安全？"><a href="#15-如何保证HTTP传输安全？" class="headerlink" title="15.如何保证HTTP传输安全？"></a>15.如何保证HTTP传输安全？</h4><ul>
<li>加密：MD5算法可以很好地解决这个问题，因为它可以将任意长度的输入串经过计算得到固定长度的输出，而且只有在明文相同的情况下，才能等到相同的密文，并且这个算法是不可逆的，即便得到了加密以后的密文，也不可能通过解密算法反算出明文</li>
<li>签名：使用 MD5算法就可以为任何文件（不管其大小、格式、数量）产生一个独一无二的“数字指纹”，借助这个“数字指纹”，通过检查文件前后 MD5 值是否发生了改变，就可以知道源文件是否被改动。</li>
</ul>
<h4 id="16-TCP如何保证数据完整？"><a href="#16-TCP如何保证数据完整？" class="headerlink" title="16.TCP如何保证数据完整？"></a>16.TCP如何保证数据完整？</h4><ul>
<li><strong>检验和</strong>：数据收发方在进行数据传输时，都会先计算校验和，如果不一致，就说明数据传输有误。</li>
<li><strong>序列号，确认应答</strong>：TCP在进行数据传输时都是进行编号的，每次接收方返回ACK时都有确认序列号。</li>
<li><strong>超时重传</strong>：如果发送方发送数据一段时间后没有收到ACK，那么就重新发送数据。</li>
<li><strong>连接管理</strong>：TCP通过三次握手建立连接，四次挥手断开连接。</li>
<li><strong>流量控制</strong>：根据接收端的能力进行数据发送。TCP协议报头包含16位的窗口大小，接收方会在返回数据时，将自己的即时窗口大小填入，发送方就会根据报文中窗口的大小控制发送速度。</li>
<li><strong>拥塞控制</strong>：会像探路一样，先发送小数据，防止拥塞<br>刚开始发送数据的时候，拥塞窗口是1，以后每次收到ACK，则拥塞窗口+1，然后将拥塞窗口和收到的窗口取较小值作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为1。这样做的目的就是为了保证传输过程的高效性和可靠性。</li>
</ul>
<h4 id="17-HTTPS原理"><a href="#17-HTTPS原理" class="headerlink" title="17.HTTPS原理"></a>17.HTTPS原理</h4><p>HTTPS通过数据加密和身份验证的方法解决了HTTP在消息传输过程中不安全的问题。</p>
<ul>
<li><p>对称加密：有一段秘钥，能通过它来加密一段信息，形成一段密文，而这段密文是不能读取的，想要读取这段密文就需要通过加密它的秘钥来解密，还原成原始信息。就是一个门只能用一把钥匙来反锁和打开。</p>
<p>对称加密进行加密和解密需要用到相同的秘钥，而这把秘钥无论是由客户端产生，还是由服务器产生都需要将这把秘钥传送给对方，这样对方才能解密你所传输的密文，但是，秘钥是需要传送给对方的，也就是说秘钥同样在传输的过程中是能够被拦截的</p>
</li>
<li><p>非对称加密：有一个公钥和与之配对的私钥，用公钥加密的数据只能用私钥来进行解密，使用私钥加密的数据只能通过私钥进行解密。</p>
<p>与对称加密一样，产生秘钥的一方需要将公钥传给对方，双方才能以这个秘钥为基础来进行通信，那在传输的过程中黑客仍然能够截取到所传输的公钥，客户端通过公钥加密数据发送给服务器，而通过公钥加密的数据只能用私钥解密，但黑客只有公钥，所以从客户端发送给服务器的消息可以认为是安全的，它不会被轻易读取，但是服务器用私钥加密传送给客户端的消息就不够安全了，因为黑客和客户端都拥有公钥，都可以对服务器发送的消息进行解密。</p>
</li>
<li><p>对称加密+非对称加密：客户端拥有秘钥A,服务器拥有公钥B和私钥C，首先，客户端向服务器发送请求，服务器接到请求，响应请求并把它的公钥B传给客户端，客户端接收到公钥B后用公钥B加密秘钥A，形成一段密文，然后把密文传给服务器，而公钥加密的密文只能用私钥解密，但我们只传输过公钥，所以只有服务器拥有私钥，能够解密这段密文得到秘钥A，这样就只有客户端和服务器这个秘钥A了，中间没有任何人拥有秘钥A，然后客户端和服务器的通信就可以通过秘钥A来进行加密解密，这样就保证了数据传输过程中的加密问题。</p>
</li>
</ul>
<p>  没有验证消息的真实性，客户端向服务器发送请求，然后服务器响应请求并返回公钥，黑客截取到公钥，然后自己生成一对公私钥，并把自己生成的公钥传给客户端，客户端无法验证其身份，误认为是服务器，就用黑客的公钥加密自己的秘钥，并把形成的密文返回给黑客，黑客用自己的私钥解密就得到了客户端的秘钥，再用截取到服务器的公钥加密客户端的秘钥，并将其发送给服务器，服务器用私钥解密得到秘钥，然后客户端服务器正常通信，但是黑客也有秘钥，这样数据仍然很危险。</p>
<ul>
<li>所以只需要对服务器的响应进行身份认证就能解决身份冒用的问题了。数字证书：数字证书由可信任的第三方颁发，相当于一个身份证，可以验证服务器的身份。数字证书包含了证书持有者的信息和公钥信息。</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Rayson Wen</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://rayson13.github.io/2022/04/08/computer-network/">https://rayson13.github.io/2022/04/08/computer-network/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"># 计算机网络</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/04/08/redis/">redis知识点</a>
            
            
            <a class="next" rel="next" href="/2022/04/08/pictest/">hexo上传图片测试</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Rayson Wen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>